import streamlit as st
import yfinance as yf
import yahoo_fin.stock_info as si
import pandas as pd
import plotly.graph_objs as go

def RSICalc(asset, start_date, end_date):
    """
    Calculates the Relative Strength Index (RSI) for a given asset and time range.
    
    Parameters:
    -----------
    asset: str
        Ticker symbol for the asset to be analyzed.
    start_date: str
        Starting date for the analysis period in YYYY-MM-DD format.
    end_date: str
        Ending date for the analysis period in YYYY-MM-DD format.
    
    Returns:
    --------
    df: pandas.DataFrame
        A DataFrame with the following columns:
        - Date: The date of the stock price data.
        - Open: The opening price of the stock.
        - High: The highest price of the stock on that date.
        - Low: The lowest price of the stock on that date.
        - Close: The closing price of the stock on that date.
        - Adj Close: The adjusted closing price of the stock on that date.
        - Volume: The trading volume of the stock on that date.
        - MA200: The 200-day moving average of the Adjusted Close price.
        - price change: The percentage change in Adjusted Close price from the previous day.
        - Upmove: The price change when it is positive, otherwise 0.
        - Downmove: The absolute value of the price change when it is negative, otherwise 0.
        - avg Up: The exponential moving average of Upmove with a span of 19 days.
        - avg Down: The exponential moving average of Downmove with a span of 19 days.
        - RS: The Relative Strength of the asset, defined as avg Up/avg Down.
        - RSI: The Relative Strength Index of the asset, defined as 100 - (100 / (1 + RS)).
        - Buy: A column that indicates whether it is a good time to buy the stock, based on the following rule:
            - If the Adj Close price is higher than the MA200 and the RSI is below 30, set Buy to 'Yes', otherwise 'No'.
    """
    df = yf.download(asset, start = start_date, end = end_date)
    df['MA200'] = df['Adj Close'].rolling(window=200).mean()
    df['price change'] = df['Adj Close'].pct_change()
    df['Upmove'] = df['price change'].apply(lambda x: x if x > 0 else 0)
    df['Downmove'] = df['price change'].apply(lambda x: abs(x) if x < 0 else 0)
    df['avg Up'] = df['Upmove'].ewm(span=19).mean()
    df['avg Down'] = df['Downmove'].ewm(span=19).mean()
    df = df.dropna()
    df = df.assign(RS=df['avg Up'] / df['avg Down'])
    df = df.assign(RSI=df['RS'].apply(lambda x: 100 - (100 / (x + 1))))
    df = df.assign(Buy='No')
    df.loc[(df['Adj Close'] > df['MA200']) & (df['RSI'] < 30), 'Buy'] = 'Yes'
    return df

def getSignals(df):
    """
    Finds the buying and selling dates for a given DataFrame that contains signals generated
    by the RSICalc() function.

    Args:
        df (pandas.DataFrame): The DataFrame containing the signals generated by the RSICalc() function.
        
    Returns:
        Tuple of two lists: The first list contains the buying dates as datetime objects, 
        while the second list contains the corresponding selling dates as datetime objects. 
        If a buying signal is found but no selling signal within 10 days, the selling date 
        is set to the last day of the 10-day window.
    """
    Buying_dates = []
    Selling_dates = []
    
    for i in range(len(df) - 11):
        if "Yes" in df['Buy'].iloc[i]:
            Buying_dates.append(df.iloc[i+1].name)
            for j in range(1, 11):
                if df['RSI'].iloc[i + j] > 40:
                    Selling_dates.append(df.iloc[i + j + 1].name)
                    break
                elif j == 10:
                    Selling_dates.append(df.iloc[i + j + 1].name)
                    
    return Buying_dates,Selling_dates

def RSI_strategy(ticker, start_date, end_date, account_balance):
    """
    Implements a trading strategy based on the Relative Strength Index (RSI) indicator.

    Parameters:
    ticker (str): Ticker symbol of the asset to be traded.
    start_date (str): Start date for the data to be retrieved in the format "YYYY-MM-DD".
    end_date (str): End date for the data to be retrieved in the format "YYYY-MM-DD".
    account_balance (float): Initial balance of the trading account in USD.

    Returns:
    None

    Displays a chart of the asset's adjusted close price with buy and sell signals based on the RSI strategy.
    Calculates and displays the win rate, cumulative profit, and final balance of the trading account.
    Raises an error if there are no trades found within the specified period, if the asset data cannot be fetched,
    or if the account balance is not a valid number.
    """
    frame = RSICalc(ticker, start_date, end_date)
    buy, sell = getSignals(frame)

    try:
        fig = go.Figure()
        fig.add_trace(go.Scatter(x=frame.index, y=frame['Adj Close'], name='Adjusted Close'))
        fig.add_trace(go.Scatter(x=frame.loc[buy].index, y=frame.loc[buy]['Adj Close'], mode='markers', marker=dict(symbol='triangle-up', color='green'), name='Buy Signal'))
        fig.add_trace(go.Scatter(x=frame.loc[sell].index, y=frame.loc[sell]['Adj Close'], mode='markers', marker=dict(symbol='triangle-down', color='red'), name='Sell Signal'))
        fig.update_layout(title=f'{ticker} RSI Strategy', xaxis_title='Date', yaxis_title='Adjusted Close Price')
        st.plotly_chart(fig, use_container_width = True)

        Buyprices = frame.Open.loc[buy]
        Sellprices = frame.Open.loc[sell]

        if Sellprices.index[0] < Buyprices.index[0]:
            Sellprices = Sellprices.drop(Sellprices.index[0])
        elif Buyprices.index[-1] > Sellprices.index[-1]:
            Buyprices = Buyprices.drop(Buyprices.index[-1])

        profitsrel = []
        for i in range(len(Sellprices)):
            if Sellprices[i] >= Buyprices[i]:
                profit = (Sellprices[i] - Buyprices[i])/Buyprices[i]
                profitsrel.append(profit)
            else:
                loss = (Buyprices[i] - Sellprices[i])/Buyprices[i]
                profitsrel.append(-loss)

        cum_profit = sum(profitsrel)
        cum_profit += 1
        win_rate = len([i for i in profitsrel if i > 0])/len(profitsrel) * 100

        st.write(f"Win Rate: {win_rate:.2f}%")
        st.write(f"Cumulative Profit: {cum_profit:.2f}") # Same thing with others.  0.5 means lose 50%.  Before changed the code, there is -0.5 and 0.5 meant profit but now it means lose
        final_balance = account_balance * cum_profit
        st.write(f"Final Balance: {final_balance:.2f}")
    except ZeroDivisionError:
        st.error("No trades found within this period.")
    except IndexError:
        st.error("Unable to fetch data.  Company could have been delisted.")
    except TypeError:
        st.error("Make sure you've entered a valid number for account balance.")

def MA_strategy(input_ticker, input_start_date, input_end_date, account_balance):
    """
    Implements a simple Moving Average trading strategy for a given stock ticker.

    Args:
        input_ticker (str): Ticker symbol of the stock to analyze.
        input_start_date (str): Start date for the analysis in the format 'YYYY-MM-DD'.
        input_end_date (str): End date for the analysis in the format 'YYYY-MM-DD'.
        account_balance (float): Starting balance for the trading account.

    Returns:
        None.

    Raises:
        ZeroDivisionError: If no trades were found within the specified period.
        IndexError: If there was an error fetching the data for the specified stock ticker.
        TypeError: If the account balance is not a valid number.

    The function downloads the historical price data for the specified stock, calculates the 50-day and 200-day
    moving averages, and generates buy and sell signals based on the crossovers between the two averages. The function
    also plots the historical asset price, the moving averages, and the buy/sell signals using Plotly. Finally, the
    function calculates the cumulative profit, win rate, and final account balance based on the trades generated by the
    strategy.
    """
    ma_df = yf.download(input_ticker, start=input_start_date, end=input_end_date)
    try:
        ma_df['MA50'] = ma_df['Adj Close'].rolling(50).mean()
        ma_df['MA200'] = ma_df['Adj Close'].rolling(200).mean()
        ma_df = ma_df.dropna()
        ma_df = ma_df[['Adj Close', 'MA50', 'MA200']]

        Buy = []
        Sell = []
        profits = []

        for i in range(len(ma_df)):
            if ma_df.MA50.iloc[i] > ma_df.MA200.iloc[i] and ma_df.MA50.iloc[i-1] < ma_df.MA200.iloc[i-1]:
                Buy.append(i)
            elif ma_df.MA50.iloc[i] < ma_df.MA200.iloc[i] and ma_df.MA50.iloc[i-1] > ma_df.MA200.iloc[i-1]:
                Sell.append(i)

        asset_price = go.Scatter(x=ma_df.index, y=ma_df['Adj Close'], name='Asset Price', line=dict(color='blue', width=1))
        ma_50 = go.Scatter(x=ma_df.index, y=ma_df['MA50'], name='MA50', line=dict(color='red', width=1))
        ma_200 = go.Scatter(x=ma_df.index, y=ma_df['MA200'], name='MA200', line=dict(color='black', width=1))
        buy_signal = go.Scatter(x=ma_df.iloc[Buy].index, y=ma_df.iloc[Buy]['Adj Close'], name='Buy Signal',
                                mode='markers', marker=dict(symbol='triangle-up', color='green', size=10))
        sell_signal = go.Scatter(x=ma_df.iloc[Sell].index, y=ma_df.iloc[Sell]['Adj Close'], name='Sell Signal',
                                mode='markers', marker=dict(symbol='triangle-down', color='red', size=10))

        data = [asset_price, ma_50, ma_200, buy_signal, sell_signal]
        layout = go.Layout(title=f"{input_ticker} Moving Average Strategy", xaxis=dict(title="Date"), yaxis=dict(title="Price"))
        fig = go.Figure(data=data, layout=layout)
        st.plotly_chart(fig, use_container_width = True)

        cum_profit = 1
        for i in range(len(Buy)):
            buy_date = ma_df.iloc[Buy[i]].name
            sell_date = ma_df.iloc[Sell[i]].name
            buy_price = ma_df.loc[buy_date, 'Adj Close']
            sell_price = ma_df.loc[sell_date, 'Adj Close']
            trade_profit = sell_price - buy_price
            profits.append(trade_profit)
            cum_profit *= (1 + trade_profit/buy_price)
            
        win_rate = (len([p for p in profits if p > 0]) / len(profits)) * 100
        st.write(f"Win Rate: {win_rate:.2f}%")
        st.write(f"Cumulative Profit: {cum_profit:.2f}") # 0.7 means lose 30%

        final_balance = account_balance * cum_profit
        st.write(f"Final Balance: {final_balance:.2f}")
    except ZeroDivisionError:
        st.error("No trades found within this period.")
    except IndexError:
        st.error("Unable to fetch data.  Company could have been delisted.")
    except TypeError:
        st.error("Make sure you've entered a valid number for account balance.")

def MACD(macd_df):
    """
    Calculate the Moving Average Convergence Divergence (MACD) indicator and the signal line for a given DataFrame of stock prices.

    Parameters:
        macd_df (pandas.DataFrame): DataFrame containing stock prices with columns 'Date' and 'Close'.

    Returns:
        None. Modifies the input DataFrame `macd_df` in place by adding the columns 'EMA12', 'EMA26', 'MACD', and 'signal', which represent the 12-day exponential moving average, 26-day exponential moving average, MACD line, and signal line, respectively.

    """
    macd_df['EMA12'] = macd_df.Close.ewm(span = 12).mean()
    macd_df['EMA26'] = macd_df.Close.ewm(span =26).mean()
    macd_df['MACD'] = macd_df.EMA12 - macd_df.EMA26
    macd_df['signal'] = macd_df.MACD.ewm(span = 9).mean()

def MACD_strategy(input_ticker, input_start_date, input_end_date, account_balance):
    """
    Implements a trading strategy based on the Moving Average Convergence Divergence (MACD) indicator using the yfinance 
    library to retrieve historical data for a given stock ticker between a specified start and end date. The strategy 
    generates buy and sell signals based on the MACD and signal lines crossing over each other, and plots the stock's 
    price with buy and sell signals highlighted. It also calculates the cumulative profit and win rate of the trades made 
    based on the buy and sell signals, and outputs the final balance of an account that invests the entire account balance 
    into the stock following the buy signals and sells all shares following the sell signals.

    Parameters
    ----------
    input_ticker : str
        Stock ticker symbol for the stock to trade.
    input_start_date : str
        Start date for retrieving historical data in the format "YYYY-MM-DD".
    input_end_date : str
        End date for retrieving historical data in the format "YYYY-MM-DD".
    account_balance : float
        The starting account balance to use for the strategy.

    Raises
    ------
    ZeroDivisionError
        If no trades are found within the specified period.
    IndexError
        If unable to fetch data, which could be due to the company being delisted.
    TypeError
        If account_balance is not a valid float number.

    Returns
    -------
    None
    """
    macd_df = yf.download(input_ticker, start=input_start_date, end=input_end_date, interval='1d')
    MACD(macd_df)

    Buy, Sell = [], []

    try:
        for i in range(2, len(macd_df)):
            if macd_df.MACD.iloc[i] > macd_df.signal.iloc[i] and macd_df.MACD.iloc[i-1] < macd_df.signal.iloc[i - 1]:
                Buy.append(i)
            elif macd_df.MACD.iloc[i] < macd_df.signal.iloc[i] and macd_df.MACD.iloc[i-1] > macd_df.signal.iloc[i - 1]:
                Sell.append(i)

        asset_price = go.Scatter(x=macd_df.index, y=macd_df['Close'], name='Asset Price', line=dict(color='blue', width=1))
        buy_signal = go.Scatter(x=macd_df.iloc[Buy].index, y=macd_df.iloc[Buy]['Close'], name='Buy Signal',
                                mode='markers', marker=dict(symbol='triangle-up', color='green', size=10))
        sell_signal = go.Scatter(x=macd_df.iloc[Sell].index, y=macd_df.iloc[Sell]['Close'], name='Sell Signal',
                                mode='markers', marker=dict(symbol='triangle-down', color='red', size=10))

        data = [asset_price, buy_signal, sell_signal]
        layout = go.Layout(title=f"{input_ticker} MACD Strategy", xaxis=dict(title="Date"), yaxis=dict(title="Price"))
        fig = go.Figure(data=data, layout=layout)
        st.plotly_chart(fig, use_container_width=True)

        Realbuys = [i + 1 for i in Buy]
        Realsells = [i + 1 for i in Sell]
        Buyprices = macd_df.Open.iloc[Realbuys]
        Sellprices = macd_df.Open.iloc[Realsells]

        if Sellprices.index[0] < Buyprices.index[0]:
            Sellprices = Sellprices.drop(Sellprices.index[0])
        elif Buyprices.index[-1] > Sellprices.index[-1]:
            Buyprices = Buyprices.drop(Buyprices.index[-1])

        profitsrel = []
        for i in range(len(Sellprices)):
            if Sellprices[i] >= Buyprices[i]:
                profit = (Sellprices[i] - Buyprices[i])/Buyprices[i]
                profitsrel.append(profit)
            else:
                loss = (Buyprices[i] - Sellprices[i])/Buyprices[i]
                profitsrel.append(-loss)

        cum_profit = sum(profitsrel)
        cum_profit += 1
        win_rate = (len([x for x in profitsrel if x > 0])/len(profitsrel))*100 if profitsrel else 0

        st.write(f"Win Rate: {win_rate:.2f}%")
        st.write(f"Cumulative Profit: {cum_profit:.2f}") # 0.7 means lose 30%
        final_balance = account_balance * cum_profit
        st.write(f"Final Balance: {final_balance:.2f}")
    except ZeroDivisionError:
        st.error("No trades found within this period.")
    except IndexError:
        st.error("Unable to fetch data.  Company could have been delisted.")
    except TypeError:
        st.error("Make sure you've entered a valid number for account balance.")

def main():
    """
    A streamlit app that allows users to select a trading strategy and input information on an asset (ticker, start and end dates, and initial account balance), and displays a visualization of the strategy's performance.

    Parameters:
    None

    Returns:
    None
    """
    st.set_option('deprecation.showPyplotGlobalUse', False)
    st.set_page_config(page_title = "Designing Intelligent Agent", page_icon = 'ðŸ“ˆ', layout = "wide")

    st.markdown("<h1 style = 'text-align: center;'>Designing Intelligent Agent</h1>", unsafe_allow_html = True)
    st.markdown("---")
    left_col, right_col = st.columns([2, 6])

    # --- Start of Strategy Selection and Information Input ---
    with left_col:
        st.markdown("###")
        strategy_list = ["Relative Strength Index", "Moving Average", "Moving Average Convergence Divergence"]
        select_strategy_list = st.selectbox("Select Strategy", strategy_list)

        # --- Start of Information Input ---
        st.markdown("---")
        st.markdown("<h4 style = 'text-align: center;'>Asset Information</h4>", unsafe_allow_html = True)

        indices_col, ticker_col = st.columns(2)
        
        with indices_col:
            indices_list = ["Dow Jones", "Nasdaq", "S&P500"]
            input_indices = st.selectbox("Indices", indices_list)

        with ticker_col:
            if input_indices == "Dow Jones":
                dow_tickers = si.tickers_dow()
                input_ticker = st.selectbox("Ticker", dow_tickers)
            elif input_indices == "Nasdaq":
                nasdaq_tickers = si.tickers_nasdaq()
                input_ticker = st.selectbox("Ticker", nasdaq_tickers)
            elif input_indices == "S&P500":
                spx_tickers = si.tickers_sp500()    
                input_ticker = st.selectbox("Ticker", spx_tickers)

        # Enter date
        left_date_col, right_date_col = st.columns(2)
        with left_date_col:
            start_date = st.date_input('Start', value = pd.to_datetime('2020-01-01'), key = "1")
        with right_date_col:
            end_date = st.date_input('End', value = pd.to_datetime('today'), key = "2")

        account_balance_input = st.text_input('Initial Balance', 'Enter Amount Here')

        if account_balance_input.isnumeric():
            # convert input to float
            account_balance_input = float(account_balance_input)
        else:
            st.error("Please enter a valid number.")

        # --- End of Information Input ---

        st.markdown("###")
        
        # --- Start of Information on Strategy ---
        with st.expander(label = "Read More"):
            if select_strategy_list == "Relative Strength Index":
                st.warning("A popular technical indicator used to determine whether an asset is overbought or oversold, the Relative Strength Index (RSI) measures the strength and velocity of price movements and generates signals to help traders determine when to buy or sell an asset.")
            elif select_strategy_list == "Moving Average":
                st.warning("A well-known technical indicator that smooths out price data by providing a constantly updated average price over a set time period. It aids traders in determining the trend's direction as well as potential levels of support and resistance in the price chart.")
            elif select_strategy_list == "Moving Average Convergence Divergence":
                st.warning("A trend-following momentum indicator that generates signals by comparing two moving averages of an asset's price. The MACD can be used to detect possible buying or selling opportunities by assisting traders in identifying changes in the momentum of the asset's price trend.")
        # --- End of Information on Strategy
    # --- End of Strategy Selection and Information Input ---

    # --- Start of Visualisation ---
    with right_col:
        if select_strategy_list == "Relative Strength Index":
            st.markdown("<h3 style = 'text-align: center;'>Relative Strength Index</h3>", unsafe_allow_html = True)
            RSI_strategy(input_ticker, start_date, end_date, account_balance_input) # RSI Strategy
        elif select_strategy_list == "Moving Average":
            st.markdown("<h3 style = 'text-align: center;'>Moving Average Strategy</h3>", unsafe_allow_html = True)
            MA_strategy(input_ticker, start_date, end_date, account_balance_input) # MA Strategy
        elif select_strategy_list == "Moving Average Convergence Divergence":
            st.markdown("<h3 style = 'text-align: center;'>Moving Average Convergence Divergence Strategy</h3>", unsafe_allow_html = True)
            MACD_strategy(input_ticker, start_date, end_date, account_balance_input)
    # --- End of Visualisation  

if __name__ == '__main__':
    main()